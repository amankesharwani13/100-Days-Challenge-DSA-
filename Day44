2196. Create Binary Tree From Descriptions
class Solution {
public:
    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {
        // set<int>s;
        // unordered_map<int,TreeNode*>m;
        // for(int i=0;i<descriptions.size();i++){
        //     if(m.find(descriptions[i][0]) != m.end()){
        //         TreeNode* temp = m[descriptions[i][0]];
        //         if(descriptions[i][2] == 1){
        //             TreeNode* l = new TreeNode(descriptions[i][1]);
        //             temp->left = l;
        //             m[descriptions[i][1]] = l;
        //         }
        //         else{
        //             TreeNode* r = new TreeNode(descriptions[i][1]);
        //             temp->right = r;
        //             m[descriptions[i][1]] = r;
        //         }
        //         s.insert(descriptions[i][1]);
        //     }
        //     else{
        //         TreeNode* temp = new TreeNode(descriptions[i][0]);
        //         m[descriptions[i][0]] = temp;
        //         if(descriptions[i][2] == 1){
        //             TreeNode* l = new TreeNode(descriptions[i][1]);
        //             temp->left = l;
        //             m[descriptions[i][1]] = l;
        //         }
        //         else{
        //             TreeNode* r = new TreeNode(descriptions[i][1]);
        //             temp->right = r;
        //             m[descriptions[i][1]] = r;
        //         }
        //         s.insert(descriptions[i][1]);
        //     }
        // }
        // int roots = -1;
        // for(int i=0;i<descriptions.size();i++){
        //     if(s.find(descriptions[i][0]) == s.end()){
        //           roots = descriptions[i][0];
        //           break;
        //     }
        // }
        // for(auto x:m){
        //     if(x.first == roots)return x.second; 
        // }
        // return NULL;



        set<int>s;
        unordered_map<int,TreeNode*>m;
        for(int i=0;i<descriptions.size();i++){
            int parent = descriptions[i][0];
            int child = descriptions[i][1];
            bool isLeft = descriptions[i][2];

            if(m.find(parent) == m.end()){
                m[parent] = new TreeNode(parent);
            }

            if(m.find(child) == m.end()){
                m[child] = new TreeNode(child);
            }

            if(isLeft){
                m[parent]->left = m[child];
            }
            else{
                m[parent]->right = m[child];
            }
            s.insert(descriptions[i][1]);
        }
        int roots = -1;
        for(int i=0;i<descriptions.size();i++){
            if(s.find(descriptions[i][0]) == s.end()){
                  roots = descriptions[i][0];
                  break;
            }
        }
        for(auto x:m){
            if(x.first == roots)return x.second; 
        }
        return NULL;

    }
};
